<!DOCTYPE html>
<html>
	<head>
		<title>TG Cloud</title>
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="{{ url_for('static', filename='js/d3.layout.cloud.js') }}"></script>
	</head>
	<body>
		<h1>Word Cloud for {{ username }}</h1>
		<script>
            
            dataset = [];

            {% for key, value in entries.iteritems() %}
                var obj = {word:'{{ key }}',
                        count: {{ value }} };
                dataset.push(obj);
            {% endfor %}



            dataset.sort(compare);
            
            initial_text_placement(dataset);
            determine_text_boundaries(dataset);
            cloud_placement_algorithm(dataset, 0);
            finalize_text_placement(dataset);
            
            // Returns a number between the two parameters
            function rand(from, to) {
                return Math.floor(Math.random() * (to - from + 1) + from);  
            };
            
            
            function initial_text_placement(dataset) {
                // List of Official TG Colors
                var color_list = ['#407db5', '#e67e22',
                                  '#27ae60', '#8e44ad',
                                  '#e74c3c'];

                
                // Scale for the font size
                var size = d3.scale.sqrt()
                            .domain(d3.extent(dataset, function(d) {return d.count;}))
                            .rangeRound([10,65])
                            .clamp(true);

                // Size of the SVG
                var dim = 800;

                svg = d3.select("body")
                        .append("svg")
                        .attr("height", dim)
                        .attr("width", dim);

                // Background color, messes with checking bounding boxes
                svg.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "#e0e0e0");

                // Create Text elements in random locations offscreen
                // Determine if it should be rotated
                // Add an ID and a color from the list
                text = svg.selectAll("text")
                        .data(dataset)
                        .enter()
                        .append("text")
                        .text(function(d) {
                            return d.word.toUpperCase();
                        })
                        .attr("font-size", function(d) {
                            return size(d.count);
                        })
                        .attr("transform", function(d) {
                            x = Math.random() >= .5 ? rand(-500,-150): rand(900, 1400);
                            y = Math.random() >= .5 ? rand(-500,-150): rand(900, 1400);
                            var deg = Math.random() > .3 ? 0 : -90;
                            d["x"] = x;
                            d["y"] = y;
                            d["deg"] = deg;                        

                            return "translate(" + x + "," + y + ")rotate(" + deg + ")";
                        })
                        .attr("id", function(d) { 
                            return d.word;
                        })
                        .attr("fill", function(d,i) {
                            return color_list[i%5];
                        })
                        /*.attr("font-family", "comfortaa")
                        .attr("font-weight", 300)
                        })*/;
                
                return dataset;
                
            };
            
            
            function determine_text_boundaries(dataset) {
                
                text = d3.selectAll("text");
                
                text.each(function(d,i) {
                    var box = this.getBoundingClientRect();
                    /*console.log(d.word, box);*/
                    var padding = 8;

                    if(d.deg === 0) {
                        d["height"] = Math.round(box.height * .6);
                        d["width"] = box.width;
                    } else {
                        d["height"] = box.height;
                        d["width"] = Math.round(box.width * .6);
                    };
                    d["T"] = box.top;
                    d["B"] = box.bottom;
                    d["L"] = box.left;
                    d["R"] = box.right;
                });

                return dataset;
            };
            
            
            function cloud_placement_algorithm(dataset, alg) {
                switch(alg) {
                    case 0:
                        return rectangular_spiral(dataset);
                        break;
                    case 1:
                        return archimedean_spiral(dataset);
                        break;
                    case 2:
                        return random_placement(dataset);
                        break;
                    default:
                        return rectangular_spiral(dataset);
                        break;
                };
                
                return dataset;
            };
            
            function rectangular_spiral(dataset) {
                // Rectangular Spiral Placement Algorithm
                // Outermost loop iterates through each item
                // Second loop picks locations along the spiral
                // Innermost loop checks the location against the
                // Current locations of all other Text elements
                
                failed = [];
                dim = d3.select("svg").node().getBoundingClientRect().width;
                
                for(i=0; i < dataset.length; i++) {
                    var x = 0;
                    var y = 0;
                    var X = 80;
                    var Y = 80;
                    var dx = 0;
                    var dy = -1;
                    loops = Math.pow(Math.max(X,Y),2);

                    for(j=0; j < loops; j++) {

                        var collision = false;

                        if((-X/2 < x && x <= X/2) && (-Y/2 < y && y <= Y/2)) {
                            var xpos = dim * .4 + x * 5;
                            var ypos = dim * .6 + y * 5;
                            dataset[i].x = xpos;
                            dataset[i].y = ypos;
                            dataset[i].T = ypos - dataset[i].height;
                            dataset[i].B = ypos;
                            dataset[i].L = xpos;
                            dataset[i].R = xpos + dataset[i].width;

                        };


                        if(x===y || (x < 0 && x===-y) || (x > 0 && x===1-y)) {
                            var temp = -dy;
                            dy = dx;
                            dx = temp;
                        };


                        for(k=0; k < dataset.length; k++) {
                            if(k===i) {
                                continue;
                            };
                            if(check_rectangle_intersect(dataset[i], dataset[k])) {
                                collision = true;
                                break;
                            };
                        };

                        if(j === (loops - 1)) {
                            dataset[i].x = -500;
                            dataset[i].y = -500;
                            failed.push(dataset[i]);
                        };

                        x+= dx;
                        y+= dy;

                        if(collision) {
                            collision = false;
                            continue;
                        } else {
                            break;
                        };

                    };
                };
                
                console.log("Failed Placements: ", failed.length, ": ", failed);
                return dataset;
                
            };

            
            
            function archimedean_spiral(dataset) {
                return dataset;
            };
            function random_placement(dataset) {
                return dataset;
            };
            
            
            
            function check_rectangle_intersect(rectA, rectB) {
                // Function to check intersection of two bounding boxes  
                return !(rectB.L > rectA.R ||
                         rectB.R < rectA.L ||
                         rectB.T > rectA.B ||
                         rectB.B < rectA.T);
            };
            
            
            function finalize_text_placement(dataset) {
                // Update and transition Text Elements to their proper locations
                
                svg = d3.select("svg");
                
                svg.selectAll("text")
                        .data(dataset)
                        .transition()
                        .delay(function(d,i) {return i/10 * 50;})
                        .duration(1000)
                        .attr("transform", function(d) {
                            if(d.deg) {
                                newX = d.x + d.width;
                            } else {
                                newX = d.x;
                            };
                            return "translate(" + newX + "," + d.y + ")rotate(" + d.deg + ")";
                        });
                
                return dataset;
            };

            function compare(a,b) {
                if(a.count < b.count) return 1;
                if(a.count > b.count) return -1;
                return 0;
            };
  
        </script>
	</body>
</html>