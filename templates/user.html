<!DOCTYPE html>
<html>
	<head>
		<title>TG Cloud</title>
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="{{ url_for('static', filename='js/d3.layout.cloud.js') }}"></script>
	</head>
	<body>
		<h1>TG Cloud</h1>
		<script>
            
            dataset = [];
            path = "{{ url_for('static', filename=username + '.csv') }}";
            
            //read_test_data(25, dataset);
            read_csv_data(0, dataset, path);
            /*console.log("read_data: ", dataset);
            initial_text_placement(dataset);
            console.log("initial_text_placement: ", dataset);
            determine_text_boundaries(dataset);
            console.log("determine_text_boundaries: ", dataset);
            cloud_placement_algorithm(dataset, 0);
            console.log("cloud_placement_algorithm: ", dataset);
            finalize_text_placement(dataset);
            console.log("finalize_text_placement: ", dataset);*/
            
            function read_test_data(len, dataset) {
                // Example Word List
                var word_list = ['chicken', 'steak', 'bread',
                             'salad', 'protein', 'whale',
                             'nutella', 'banana', 'squid',
                             'rice', 'pasta', 'ostrich',
                             'rhino', 'pita', 'lemon',
                             'pie', 'chocolate', 'apple',
                             'burger', 'icecream', 'fruit', 
                             'grain', 'oats', 'whey', 'casein'];
                 
                 /*var dataset = [];*/
                 
                // Create the dataset using items from the list and a random size
                for(i=0; i < len; i++) {

                    var obj = {'word': word_list[i],
                               'count': rand(10,55)};

                    dataset.push(obj);
                };
                
                return dataset;
            
            };
            
            function read_csv_data(len, dataset, path) {
                d3.csv(path, function(error, data) {
                    console.log(data);

                    dataset = data;
                    /*data.forEach(function(d) {
                        obj = {'word': d.word,
                               'count': d.count};
                        dataset.push(obj);
                    }); */
                    console.log("read_data: ", dataset);
                    initial_text_placement(dataset);
                    console.log("initial_text_placement: ", dataset);
                    determine_text_boundaries(dataset);
                    console.log("determine_text_boundaries: ", dataset);
                    cloud_placement_algorithm(dataset, 0);
                    console.log("cloud_placement_algorithm: ", dataset);
                    finalize_text_placement(dataset);
                    console.log("finalize_text_placement: ", dataset);
                });
                
                return dataset;
                       
            };
            
            // Returns a number between the two parameters
            function rand(from, to) {
                return Math.floor(Math.random() * (to - from + 1) + from);  
            };
            
            
            function initial_text_placement(dataset) {
                // List of Official TG Colors
                var color_list = ['#407db5', '#e67e22',
                                  '#27ae60', '#8e44ad',
                                  '#e74c3c'];

                
                // Scale for the font size
                var size = d3.scale.sqrt()
                            .domain([d3.min(dataset, function(d) {return d.count;}) , d3.max(dataset, function(d) {return d.count;}) ])
                            .range([10,65]);

                // Size of the SVG
                var dim = 800;

                svg = d3.select("body")
                        .append("svg")
                        .attr("height", dim)
                        .attr("width", dim);

                // Background color, messes with checking bounding boxes
                svg.append("rect")
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", "#e0e0e0");

                // Create Text elements in random locations offscreen
                // Determine if it should be rotated
                // Add an ID and a color from the list
                text = svg.selectAll("text")
                        .data(dataset)
                        .enter()
                        .append("text")
                        .text(function(d) {
                            return d.word.toUpperCase();
                        })
                        .attr("font-size", function(d) {
                            return size(d.count);
                        })
                        .attr("transform", function(d) {
                            x = Math.random() >= .5 ? rand(-500,-150): rand(900, 1400);
                            y = Math.random() >= .5 ? rand(-500,-150): rand(900, 1400);
                            var deg = Math.random() > .2 ? 0 : -90;
                            d["x"] = x;
                            d["y"] = y;
                            d["deg"] = deg;                        

                            return "translate(" + x + "," + y + ")rotate(" + deg + ")";
                        })
                        .attr("id", function(d) { 
                            return d.word;
                        })
                        .attr("fill", function(d,i) {
                            return color_list[i%5];
                        })
                        /*.attr("font-family", "comfortaa")
                        .attr("font-weight", 300)
                        })*/;
                
                return dataset;
                
            };
            
            
            function determine_text_boundaries(dataset) {
                
                text = d3.selectAll("text");
                
                text.each(function(d,i) {
                    var box = this.getBoundingClientRect();
                    /*console.log(d.word, box);*/
                    var padding = 8;

                    if(d.deg === 0) {
                        d["height"] = Math.round(box.height * .6);
                        d["width"] = box.width;
                    } else {
                        d["height"] = box.height;
                        d["width"] = Math.round(box.width * .6);
                    };
                    d["T"] = box.top;
                    d["B"] = box.bottom;
                    d["L"] = box.left;
                    d["R"] = box.right;
                });

                return dataset;
            };
            
            
            function cloud_placement_algorithm(dataset, alg) {
                switch(alg) {
                    case 0:
                        return rectangular_spiral(dataset);
                        break;
                    case 1:
                        return archimedean_spiral(dataset);
                        break;
                    case 2:
                        return random_placement(dataset);
                        break;
                    default:
                        return rectangular_spiral(dataset);
                        break;
                };
                
                return dataset;
            };
            
            function rectangular_spiral(dataset) {
                // Rectangular Spiral Placement Algorithm
                // Outermost loop iterates through each item
                // Second loop picks locations along the spiral
                // Innermost loop checks the location against the
                // Current locations of all other Text elements
                
                failed = [];
                dim = d3.select("svg").node().getBoundingClientRect().width;
                
                for(i=0; i < dataset.length; i++) {
                    var x = 0;
                    var y = 0;
                    var X = 80;
                    var Y = 80;
                    var dx = 0;
                    var dy = -1;
                    loops = Math.pow(Math.max(X,Y),2);

                    for(j=0; j < loops; j++) {

                        var collision = false;

                        if((-X/2 < x && x <= X/2) && (-Y/2 < y && y <= Y/2)) {
                            var xpos = dim * .4 + x * 5;
                            var ypos = dim * .6 + y * 5;
                            dataset[i].x = xpos;
                            dataset[i].y = ypos;
                            dataset[i].T = ypos - dataset[i].height;
                            dataset[i].B = ypos;
                            dataset[i].L = xpos;
                            dataset[i].R = xpos + dataset[i].width;

                        };


                        if(x===y || (x < 0 && x===-y) || (x > 0 && x===1-y)) {
                            var temp = -dy;
                            dy = dx;
                            dx = temp;
                        };


                        for(k=0; k < dataset.length; k++) {
                            if(k===i) {
                                continue;
                            };
                            if(check_rectangle_intersect(dataset[i], dataset[k])) {
                                collision = true;
                                break;
                            };
                        };

                        if(j === (loops - 1)) {
                            dataset[i].x = -500;
                            dataset[i].y = -500;
                            failed.push(dataset[i]);
                        };

                        x+= dx;
                        y+= dy;

                        if(collision) {
                            collision = false;
                            continue;
                        } else {
                            break;
                        };

                    };
                };
                
                console.log("Failed Placements: ", failed.length, ": ", failed);
                return dataset;
                
            };

            
            
            function archimedean_spiral(dataset) {
                return dataset;
            };
            function random_placement(dataset) {
                return dataset;
            };
            
            
            
            function check_rectangle_intersect(rectA, rectB) {
                // Function to check intersection of two bounding boxes  
                return !(rectB.L > rectA.R ||
                         rectB.R < rectA.L ||
                         rectB.T > rectA.B ||
                         rectB.B < rectA.T);
            };
            
            
            function finalize_text_placement(dataset) {
                // Update and transition Text Elements to their proper locations
                
                svg = d3.select("svg");
                
                svg.selectAll("text")
                        .data(dataset)
                        .transition()
                        .delay(function(d,i) {return i/10 * 100;})
                        .duration(1000)
                        .attr("transform", function(d) {
                            if(d.deg) {
                                newX = d.x + d.width;
                            } else {
                                newX = d.x;
                            };
                            return "translate(" + newX + "," + d.y + ")rotate(" + d.deg + ")";
                        });
                
                return dataset;
            };
  
        </script>
	</body>
</html>